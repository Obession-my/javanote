## JVM笔记



### 类加载 ###

#### 1、加载阶段

``` 
从本地或者网络中读取文件以二进制流的方式加载到虚拟机中，生成class实例。
```

#### 2、链接阶段

```
（1）验证阶段，目的是为了验证class文件的合法性，加载类的正确性，不会危害虚拟机。主要包括：文件格式、元数据验证，字节码验证，付号	   引用验证。
（2）准备阶段，为类变量分配内存并设置变更的默认值；不包含final修饰的static变量，再准备阶段就赋值了。不会为实例变量初始化，类变量	会分配再方法区中，实例变量会随着对象一块分配在java堆中。
（3）解析阶段，一般是在初始化之后执行的，是为了将付号引用转换成直接引用，主要针对接口、字段、类方法、接口方法、方法类型等。
```

#### 3、初始化阶段

``` 
（1）就是执行类构造器方法<clinit>（）方法的过程
（2）不需要我们定义<clinit>()方法是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句整合而来的。如果没有静态变量或者代码块是不会有这个方法的。
（3）构造器的指令是按照语句在源文件中出现的顺序执行的。
（4）<clinit>()不同于类的构造器（<init>()）。
（5）若该类有父类，先执行父类的构造器。
（6）虚拟机保证一个类的<clinit>()方法执行的在多线程下被同步加锁。
```

### 类的加载器 ###

#### 1、引导类加载器 ####

```
主要是加载java的核心类库的。c和c++编写的
```

#### 2、自定义加载器 ###

```
  扩展类加载器、系统类加载器的统称。我们定义的类默认使用系统类加载器。
```

### JVM GC可达性算法

#### 可以是GC roots

```
（1）虚拟机栈中引用的对象；
（2）方法区中静态属性引用的对象；
（3）方法区中常量引用的对象；
（4）在本地方法栈中JNI(Nitive方法)引用的对象；
（5）Java虚拟机中内部的引用（如基本数据类型对应的CLass）；
（6）被同步锁持有的对象；
（7）反应Java虚拟机情况的内部JMXBean、JVMTI中注册的回调，本地代码缓存等。
```

#### GC回收机制

```
	当发现不可达后也不是立即回收，至少要被标记两次。
	当发现对象与GC Roots没有相连的引用链，进行第一次标记；后来进行一次筛选，条件是对象是否有必要执行finalize()方法，没有或者已经执行过了，则进行第二次标记。
    	当发现有必要finalize()方法，会将这个对象放在一个F-Quere的队列中，稍后会由虚拟机自动建立的、地优先调度的Finalize线程去执行各自的finalize方法。
    这里的‘执行’是指回触发这个方法开始执行，并不承诺会等这个方法执行完毕。finalize（）方法是对象逃脱被回收的最后一次机会，稍后收集器会对队列中的对象进行
    二次小规模的标记，如果对象在finalize（）方法中重新与任何引用链上的对象建立联系，那在第二次被标记时就会将它移除‘即将回收的集合’中。
```

### 引用：（以下引用关系强度依次递减）

#### 强引用

``` 
比如Object o = new Object()。这种关系还在就永远不会被GC回收。
```

#### 软引用

```
描述又通但非必须的对象，在系统将要发生内存溢出之前就会将这些对象列进回收列表，进行二次回收（1.2后SoftReference类）。
```

#### 弱引用

```
也是非必须的对象，在下次GC发生的时候，无论是否内存足够，都会进行回收（1.2后提供WeakReferencr类）。
```

#### 虚引用

```
也成为‘幽灵引用’和‘幻影引用’，此引用的存在不会对对象的生存时间有任何影响，设置它的目的是为了在GC回收时系统收到一个通知（1.2后提供PhantomReference类）。
```

### GC算法：

#### 1、标记-清除算法：

##### 缺点是：

```
1.当内存中可回收的对象比较多时，大量标记，大量清除执行效率地下。
2.回收之后就内存出碎片化现象，当大对象来时不得不提前触发一次GC;
```

#### 2、标记-复制法：

##### 缺点是：

~~~
1.把内存分成两块，只是用其中一块，有点浪费。
2.当内存中存在大量存活的对象，存在大量的内存间复制。
~~~

##### 优点：

~~~
 1.解决了内存碎片化的现象。
 2.大多数虚拟机采用这种GC算法,但是对其进行了优化:
    （1）将新生代分成三部分：Eden区两个survivor区。每次使用是Eden和一个survivor区。Eden和survivor大小比例是，8：1：1。
    （2）对象分配都是在一个Eden和一个survivor区域。当发生GC后将存活的对象复制到另外一个survivor区域。其他区域全部清除。当survivor不足以容纳一次MinorGC是，就需要进入老年代了。
~~~

#### 3、标记-整理法：

##### 缺点：

```
标记完之后移动、整理内存，特别是在老年代，大量对象被移动，更新所有引用，必须让整个程序停止。被后来人称为“stop the world”。
```

### JVM运行时栈

#### 栈帧

~~~ 
栈帧是栈的存储单位，可以理解为一个方法对应一个栈帧。
~~~

#### 栈帧里面有什么

~~~
栈帧里面包含局部变量表[Local Varibles (LV) ],操作数栈或表达式栈[Operand Stack]，动态链接[指向运行时常量区的方法引用]（Dynamic Linking），方法返回地址[方法正常退出或者异常退出的信息]，一些附加信息。
~~~

#### 局部变量表

~~~
1.也可以称为局部变量数组或者本地变量表
2.定义为一个数字数组，主要存储方法参数和定义在方法内部的局部变量，包括基本数据类型，对象引用，returnAdress类型。
3.建立在栈上所以不存在数据安全。
4.局部变量表在程序编译期间就已经确定大小。在程序运行期间不被修改。保存在方法的Code属性的maximum local varibles数据中。
5.方法嵌套调用的次数由栈大小决定。
6.局部变量表中的变量只在当前方法调用中才有效。随着方法栈帧的销毁而销毁。
~~~

#### 局部变量表的存储单位-槽（slot）

~~~
1.jvm会为局部变量表里的每一个slot分配一个索引。通过这个索引可以访问到局部变量表中的变量值。
2.当一个实例方法被调用的时候，它的方法参数和局部变量，都会按照顺序复制到局部变量表中的每一个slot上。
3.访问局部变量表中的一个64bit的局部变量，只需要使用前一个索引即可。
4.如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会被放在index为0的位置。
5.存在重复利用。比如在局部变量表中if中创建一个变量，那么当出了大括号后这个变量就会被销毁，后来定义的变量就会使用这个槽位。
~~~

#### 操作数栈

~~~
使用数组来实现的栈，是真正运算的地方，数据压栈运算，结果出栈。
~~~

#### 动态链接

~~~
1.主要是指向运行时常量池的方法引用。
2.每一个栈帧中都包含一个指向运行时常量池中的该栈帧所属方法的引用，目的就是使当前方法支持实现动态链接（Dynamic Linking）。
3.在java文件编译成字节码文件时，所有的方法和变量都会作为付号引用保存在class文件的常量池中。比如，描述一个方法调用其他方法时，就   是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
~~~









