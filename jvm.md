## JVM笔记



### 类加载 ###

#### 1、加载阶段

``` 
从本地或者网络中读取文件以二进制流的方式加载到虚拟机中，生成class实例。
```

#### 2、链接阶段

```
（1）验证阶段，目的是为了验证class文件的合法性，加载类的正确性，不会危害虚拟机。主要包括：文件格式、元数据验证，字节码验证，符号   引用验证。
（2）准备阶段，为类变量分配内存并设置变更的默认值；不包含final修饰的static变量，再准备阶段就赋值了。不会为实例变量初始化，类变量	会分配再方法区中，实例变量会随着对象一块分配在java堆中。
（3）解析阶段，一般是在初始化之后执行的，是为了将付号引用转换成直接引用，主要针对接口、字段、类方法、接口方法、方法类型等。
```

#### 3、初始化阶段

``` 
（1）就是执行类构造器方法<clinit>（）方法的过程
（2）不需要我们定义<clinit>()方法是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句整合而来的。如果没有静态变量或者代码块是不会有这个方法的。
（3）构造器的指令是按照语句在源文件中出现的顺序执行的。
（4）<clinit>()不同于类的构造器（<init>()）。
（5）若该类有父类，先执行父类的构造器。
（6）虚拟机保证一个类的<clinit>()方法执行的在多线程下被同步加锁。
```

### 类的加载器 ###

#### 1、引导类加载器 ####

```
主要是加载java的核心类库的。c和c++编写的
```

#### 2、自定义加载器 ###

```
  扩展类加载器、系统类加载器的统称。我们定义的类默认使用系统类加载器。
```

#### GC回收机制

```
	当发现不可达后也不是立即回收，至少要被标记两次。
	当发现对象与GC Roots没有相连的引用链，进行第一次标记；后来进行一次筛选，条件是对象是否有必要执行finalize()方法，没有或者已经执行过了，则进行第二次标记。
    	当发现有必要finalize()方法，会将这个对象放在一个F-Quere的队列中，稍后会由虚拟机自动建立的、地优先调度的Finalize线程去执行各自的finalize方法。
    这里的‘执行’是指回触发这个方法开始执行，并不承诺会等这个方法执行完毕。finalize（）方法是对象逃脱被回收的最后一次机会，稍后收集器会对队列中的对象进行
    二次小规模的标记，如果对象在finalize（）方法中重新与任何引用链上的对象建立联系，那在第二次被标记时就会将它移除‘即将回收的集合’中。
```

### finalize()

~~~
可以被重写，对象被GC之前会调用改方法，并且我们自己不要尝试主动调用改方法。
原因：1.调用改方法可能导致对象复活。
	 2.finalize()方法什么时候执行，是不能确定得，它是由gc线程控制得。
	 3.finalize()如果写得不好是很影响gc性能得。
~~~



### 引用：（以下引用关系强度依次递减）

#### 强引用

``` 
比如Object o = new Object()。这种关系还在就永远不会被GC回收。
```

#### 软引用

```
描述又通但非必须的对象，在系统将要发生内存溢出之前就会将这些对象列进回收列表，进行二次回收（1.2后SoftReference类）。
```

#### 弱引用

```
也是非必须的对象，在下次GC发生的时候，无论是否内存足够，都会进行回收（1.2后提供WeakReferencr类）。
```

#### 虚引用

```
也成为‘幽灵引用’和‘幻影引用’，此引用的存在不会对对象的生存时间有任何影响，设置它的目的是为了在GC回收时系统收到一个通知（1.2后提供PhantomReference类）。
```

### GC标记算法

#### 引用计数算法

~~~
实现：对每个对象都保存一个整形的引用计数属性，记录被引用的情况。
优点：判断垃圾效率高，回收没有延迟性。
缺点：1.需要单独的字段存储计数器，增加了对象的存储的空间开销。2.每次赋值都需要更新计数器，增加了时间开销。3.无法处理循环引用的情		   况。导致了java并没有采用这中标记算法。 
~~~

#### GC可达性算法

*注意：使用改算法判断是否可回收时，分析工作必须在一个能保证一致性的快照中进行。内存不能是实时变化的。*

##### 可作为GC Roots

~~~
（1）虚拟机栈中引用的对象；
（2）方法区中静态属性引用的对象；
（3）方法区中常量引用的对象；
（4）在本地方法栈中JNI(Nitive方法)引用的对象；
（5）Java虚拟机中内部的引用（如基本数据类型对应的CLass）；
（6）被同步锁持有的对象；
（7）反应Java虚拟机情况的内部JMXBean、JVMTI中注册的回调，本地代码缓存等。
（8）所有被同步锁（synchronized）持有的对象。
~~~

### GC清除算法：

#### 1、标记-清除算法：

##### 缺点是：

```
1.当内存中可回收的对象比较多时，大量标记，大量清除执行效率地下。
2.回收之后就内存出碎片化现象，当大对象来时不得不提前触发一次GC;
```

##### 何为清除？

~~~
这里的清除并不是真的置空，而是把需要清除的对象地址放在空闲列表中。下次有新的对象来时，判断垃圾的空间是否足够，如果足够就直接覆盖。
~~~

#### 2、标记-复制法：

##### 缺点是：

~~~
1.把内存分成两块，只是用其中一块，有点浪费。
2.当内存中存在大量存活的对象，存在大量的内存间复制。
~~~

##### 优点：

~~~
 1.解决了内存碎片化的现象。
 2.大多数虚拟机采用这种GC算法,但是对其进行了优化:
    （1）将新生代分成三部分：Eden区两个survivor区。每次使用是Eden和一个survivor区。Eden和survivor大小比例是，8：1：1。
    （2）对象分配都是在一个Eden和一个survivor区域。当发生GC后将存活的对象复制到另外一个survivor区域。其他区域全部清除。当survivor不足以容纳一次MinorGC是，就需要进入老年代了。
~~~

#### 3、标记-整理法：

##### 缺点：

```
标记完之后移动、整理内存，特别是在老年代，大量对象被移动，更新所有引用，必须让整个程序停止。被后来人称为“stop the world”。
```

### JVM运行时栈

#### 栈帧

~~~ 
栈帧是栈的存储单位，可以理解为一个方法对应一个栈帧。
~~~

#### 栈帧里面有什么

~~~
栈帧里面包含局部变量表[Local Varibles (LV) ],操作数栈或表达式栈[Operand Stack]，动态链接[指向运行时常量区的方法引用]（Dynamic Linking），方法返回地址[方法正常退出或者异常退出的信息]，一些附加信息。
~~~

#### 局部变量表

~~~
1.也可以称为局部变量数组或者本地变量表
2.定义为一个数字数组，主要存储方法参数和定义在方法内部的局部变量，包括基本数据类型，对象引用，returnAdress类型。
3.建立在栈上所以不存在数据安全。
4.局部变量表在程序编译期间就已经确定大小。在程序运行期间不被修改。保存在方法的Code属性的maximum local varibles数据中。
5.方法嵌套调用的次数由栈大小决定。
6.局部变量表中的变量只在当前方法调用中才有效。随着方法栈帧的销毁而销毁。
~~~

#### 局部变量表的存储单位-槽（slot）

~~~
1.jvm会为局部变量表里的每一个slot分配一个索引。通过这个索引可以访问到局部变量表中的变量值。
2.当一个实例方法被调用的时候，它的方法参数和局部变量，都会按照顺序复制到局部变量表中的每一个slot上。
3.访问局部变量表中的一个64bit的局部变量，只需要使用前一个索引即可。
4.如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会被放在index为0的位置。
5.存在重复利用。比如在局部变量表中if中创建一个变量，那么当出了大括号后这个变量就会被销毁，后来定义的变量就会使用这个槽位。
~~~

#### 操作数栈

~~~
使用数组来实现的栈，是真正运算的地方，数据压栈运算，结果出栈。
~~~

#### 动态链接

~~~
1.主要是指向运行时常量池的方法引用。
2.每一个栈帧中都包含一个指向运行时常量池中的该栈帧所属方法的引用，目的就是使当前方法支持实现动态链接（Dynamic Linking）。
3.在java文件编译成字节码文件时，所有的方法和变量都会作为付号引用保存在class文件的常量池中。比如，描述一个方法调用其他方法时，就   是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
~~~

#### 方法返回地址

~~~
存储的时pc寄存器的值。
一个方法正常执行之后，具体需要那一条指令返回，需要根据方法返回实际类型来定。
~~~

### 本地方法栈

~~~
和jvm栈一个特性，有oom。
当我们开始调用一个本地方法时，它就进入了一个全新的领域，就不再受到jvm的限制，和jvm是一个层次上的。和jvm有同样的权限。
本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。
甚至可以直接使用本地的寄存器。
可以从本地堆中分配任意数量的内存。
~~~

### 堆

~~~
-NewRatio 设置新生代和老年代的比例。默认是1：2
-XX:(-/+)UseAdaptiveSizePolicy 	-:关闭内存自适应的分配策略。
-XX:SurvivorRatio=?  设置新生代中伊甸园区与幸存者区的比例。
-Xmn:设置新生代的最大内存大小。
-Xms:设置堆的初始大小(默认时内存的1/64)。
-Xmx:设置堆的最大大小（默认时1/4）。
-XX:+PrintFlagsInitial : 查看所有参数默认初始值。
-XX:+PrintFlagsFinal : 查看所有参数的最终值。
-XX:SurvivorRatio : 配置新生代中Eden和S0,S1的占比。
-XX:MaxTenuringThreshold : 设置新生代垃圾的最大你年龄。
-XX:PrintGC 或者 -verbose:GC 打印GC的简要信息
-XX:HandlePromotionFailure : 是否设置空间分配担保。（默认是true，在jdk7之后这个参数就已经失效了，虽然保留了这个参数）
查看某个参数的指令：{jsp:查看当前进程；jinfo -flag 参数 进程id}
（在垃圾回收时，只要老年代的连续空间大于新生代对象的总大小或者历次晋升老年代的平均大小，就会惊醒Minor GC否则就进行Full GC）
-XX:PrintEscapeAnalysis 查看逃逸分析的结果。
-XX:+DoEscapeAnalysis 开启逃逸分析，jdk1.6后默认开启 
-XX:+EliminateAllocations:开启标量替换（默认打开）
-XX:+PrintStringTableStatistics 打印字符串常量池具体信息。
~~~

#### 年轻代

~~~
细分成伊甸园区，幸存者0，幸存者1。
~~~

#### 老年代

~~~

~~~

### GC的区别

#### 部分收集

~~~
不是对整个堆的收集，分为：
	新生代收集，Minor GC/ Young GC 只是对新生代（Edor,S0,S1）收集。
	老年代收集，Major GC/ Old GC 对整个老年代收集
		目前也只有CMS GC 会有单独收集老年代收集的行为。
		很多时候Major GC和Full GC混合使用，需要具体分辨是老年代回收还是整堆的回收。
	混合收集，Mixed GC 收集整个新生代和部分老年代。
		目前只有G1 GC 会有这种行为.
~~~

#### 整堆收集

~~~
Full GC,针对整个堆和方法区的收集
~~~

#### 年轻代GC 的触发条件.

~~~
当年轻代空间不足时触发Minor GC,这里的年轻代指的是Edor园区.Survivor区满并不会触发Minor GC.一般Minor GC 执行比较频繁,速度也比较快,会发生STW行为,停止一切用户线程.
~~~

#### System.gc()

~~~
当调用这个方法时，jvm不保证一定触发垃圾回收。触发的时full GC。
~~~

#### runFinaliztaion()

~~~
jvm强制调用失去引用的对象的finalize()方法。
~~~



### 什么是TLAB(thread Local Allocation Buffer)

~~~
JVM 为每一个线程分配一个私有缓冲区，包含在Eden区中，避免多线程同时分配对象操作同一块空间，但是TLAB占用的空间是Eden区的1%。在开发工程中，可以设置-XX:+UseTLAB设置使用TALB。默认情况下TLAB是打开的。可以通过参数-XX:TLABWasterTargetPencent设置TLAB占用Eden空间的比例。当TLAB空间不够时，JVM会尝试使用加锁的机制在Eden区中分配对象。确保数据操作的原子性。
~~~

### 堆是对象分配的唯一方式吗？

~~~
否：逃逸分析技术逐渐成熟，栈上分配，标量替换优化，使对象分配在堆上变得不在那么绝对，如果一个对象并没有逃逸出方法的话，那么就有可能优化成栈上分配。也无需垃圾回收。
~~~

### 逃逸分析

~~~
基本行为就是分析对象的动态作用域。如果一个对象在方法中定义，只是在本方法内部使用，就认为该对象没有发生逃逸。如果被外部调用，就认为发生了jdk6之后默认开启了逃逸分析。可以使用-XX:PrintEscapeAnalysis 查看逃逸分析的结果。
~~~

### 基于逃逸分析Jvm会做一下优化

#### 栈上分配

~~~
将对象在栈上分配。如果对象没有发生逃逸的话可能是在栈上分配的。
~~~

#### 同步省略（锁消除）

~~~
一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以选择不同步。
~~~

#### 分离对象或标量替换

~~~
有的对象可能不需要作为一个连续的内存结构存在也可以被访问到那么对象的部分或者全部可以不存储在内存中，存在cpu的寄存器中。
~~~

### 方法区

~~~
主要存储的是：类型信息，常量，静态变量，即使编译器编译后的代码缓存。（类型信息，运行时常量池，静态变量，JIT代码缓存，域信息，方法信息）
回收的主要信息就是，常量池中废弃的常量和不再使用的类型。
方法区‘类型信息’的回收需要满足的条件比较苛刻，（1）该类的所有实例都已经被回收。（2）加载该类的类加载器也已经被回收。（3）该类对应得java.lang.Class 对象没有在任何地方被引用。
~~~

#### 方法区的演进细节

~~~
jdk1.6: 有永久代（permanent Generation），静态变量放在永久代上。
jdk1.7: 有永久代，但是已经逐步“去永久代”，字符串常量池，静态变量移除，保存在堆中。
jdk1.8: 没有永久代。类型信息，字段，方法，常量保存在本地内存的元空间，但是 字符串常量池，静态变量 仍在堆中。
~~~

#### jdk1.8为什么去除永久代

~~~
1.永久代的空间大小很难确定。
2.对永久代调优很困难。
~~~

#### 字符串常量池为什么从永久代移到了堆空间中

~~~
因为永久代的回收率很低，只有full GC 的时候才会被回收。而full GC只有永久代、老年代空间不足的时候才会触发。这就导致回收的效率不是很高。放在堆空间中就能更快的被回收。
~~~

### 创建类的几种方式

~~~
1.使用new的方式创建
2.Class的newInstance()方法，只能调用空参的构造方法，权限必须是public。（现在已经不再推荐使用）
3.Constructor的newInstance(Xxx)方法，反射的方式，可以调用空参和带参的构造器，权限没有要求。
4.使用clone()，不调用任何的构造器，当前类需要实现Cloneable接口，现先clone方法。
5.使用反序列化，从文件中，或者从网络中获取一个对象二进制流。
6.使用第三方类库，Objenesis
~~~

### 对象创建的步骤

~~~
1.判断对象的类是否加载、链接、初始化
2.为对象分配内存
	如果内存规整使用指针碰撞法。
	如果内存不规整，虚拟机会维护一个列表，在列表中找到一个足够大的空间来放对象，然后更新列表。
3.处理并发安全问题
	采用CAS失败重试、区域加锁保证更新的原子性。
	每个线程预先分配一快TLAB
4.（默认初始化）初始化分配到的空间，为所有属性设置默认值，保证对象实例字段在不赋值时可以使用。
5.设置对象的对象头。
6.执行init方法进行初始化（显示初始化）。
~~~

### 内存布局

#### 对象头

~~~
1.运行时元数据（Mark Word）
	（1）HashCode【哈希值】
	（2）GC分代年龄
	（3）锁状态标志
	（4）线程持有的锁
	（5）偏向线程id
	（6）偏向时间戳
2.类型指针
	指向类元数据InstanceKlass,确定该对象所属的类型。
注：如过创建的是数组，还需要额外记录数组的长度。
~~~

#### 实例数据

~~~
说明：是对象真正存储的有效信息，包括程序中定义的各种类型的字段（包括父类继承下来的和自己本身拥有的）。
规则：（1）相同宽度的字段总是被分配在一起。
	 （2）父类中定义的变量会放在子类之前。
	 （3）如果CompactFields参数为true,子类的窄变量可能插入到父变量的空隙中。
~~~

#### 对其填充

~~~
只是起到占位符的作用。
~~~

### 对象访问定位

##### JVM如何通过栈帧中的对象引用访问对象实例的？

~~~
定位：通过栈上的reference引用，记录了实例的地址值。
对象的访问分成两种：1.句柄访问
					缺点：效率变慢。
					优点：当对象发生移动，不需要改变栈中的引用地址，只需要改变堆中的句柄池中的地址就行了。
				 2.直接指针（HotSpot采用）
				 	缺点：当对象发生移动，需要改变栈中的引用地址.
				 	优点：访问效率更高，不需要维护句柄池空间。
~~~

###  String 的基本特性

~~~
string常量池中不会存储相同的字符串。
字符串常量池是一个固定大小的Hashtable（数组+链表）。
-XX:StringTableSize可设置StringTable长度。
在jdk1.6中StringTable长度是固定的就是1009。
在jdk1.7中StringTable的默认长度就是60013，StringTable大小的设置没有要求。
jdk8开始，设置StringTable的长度的话，1009就是可以设置的最小值。
字符串拼接：
（1）常量和常量的拼接操作结结构就在常量池中，原理是编译器优化。
（2）只要其中有一个是变量，结果就在堆中，变量拼接的原理是StringBuillder。
（3）如果拼接的结果调用intern(),将结果放在常量池中。
~~~

### String的intern（）总结

~~~
jdk1.6:将这个字符串对象尝试放入串池中。
	如果串池中有，并不会放入。返回已有的串池中的对象的地址。
	如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址。
jdk1.7:将这个字符串对象尝试放入串池中。
	如果串池中有,并不会放入。返回已有的串池中的对象的地址。
	如果没有，则会把对象的引用地址复制一份，放入串池中，并返回串池中的引用地址。
~~~

### Parallel Scavenge回收器：吞吐量优先。

~~~
适合在后台运算而不需要太多交互的任务，因此在常见的服务器中使用。
在jdk1.6之后增加了parallel Old 收集器工作在老年代。也是采用并行回收。有STW
~~~

### Parallel 参数设置

~~~
-XX:UseParallelGC:手动指定年轻代使用Parallel并行收集器。
-XX:UseParallelOldGC :手动指定年轻代使用Parallel并行收集器。
-XX:ParallelGCThreads :设置年轻代并行收集器的线程数，最好与CPU数量相等。
	--默认情况下，当cpu数量小于8个，值就等于CPU数量。
	--当cpu数量大于8个，值就等于3+[5*cpu_count/8]
~~~

### CMS低延时GC(不能说没有STW现象)

~~~
1.初始化标记阶段（STW）标记直接引用，就是GC roots。暂停时间很短。
2.并发标记阶段，和用户线程并发执行，这时标记占用时间将比较长。
3.重新标记阶段（STW），修正并发标记载过程中的标记偏差（因为有用户线程在执行），时间也较短暂。
4.并发清理阶段，和用户线程并发执行，清理垃圾。
~~~

### CMS弊端

~~~
1.产生内存碎片，在分配大对象的时候不得不提前触发full GC
2.CMS对CPU资源比较敏感，在并发阶段，虽不会停下用户线程，但会使应用程序变慢，总吞吐量降低。 
3.无法处理浮动垃圾，在并发标记阶段，用户线程产生的垃圾并不能回收，只能在下一次gc时才能清理。
4.在GC时，用户线程也在跑，当内存空间不够时将启动备用方案，让Serial old收集器工作。这将会耗费大量的时间。
~~~









